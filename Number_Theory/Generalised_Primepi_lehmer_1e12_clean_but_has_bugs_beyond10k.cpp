#include <bits/stdc++.h>
using namespace std;
// count prime timings
// n = 1e+08 : 5761374(time: 0.000147s)
// n = 1e+09 : 50847513(time: 0.000625s)
// n = 1e+10 : 455055057(time: 0.005021s)
// n = 1e+11 : 4118094746(time: 0.069805s)
// n = 1e+12 : 37607404117(time: 0.666591s)
// n = 1e+13 : 346029867905(time: 7.42527s)

// Sum prime timings
// n = 1e+09 : -5507193164078852(time: 0.001258s)
// n = 1e+10 : 4346955191190699564(time: 0.00956s)
// n = 1e+11 : -2366641945361200515(time: 0.098383s)
// n = 1e+12 : 9085273575588645537(time: 1.00599s)
// n = 1e+13 : -2701895728919619381(time: 8.78676s)

using ll = long long;
// using ll = __int128;

void ASSERT(ll minval, ll variable, ll maxval) {
  if (!(minval <= variable && variable <= maxval)) {
    cout << "ASSERT FAILED: " << minval << " " << variable << " " << maxval
         << " @ " << __FILE__ << " (" << __LINE__ << ")" << std::endl;
    exit(0);
  }
}

void ASSERT(bool condition) {
  if (!(condition)) {
    cout << "ASSERT FAILED: "
         << " @ " << __FILE__ << " (" << __LINE__ << ")" << std::endl;
    exit(0);
  }
}

std::ostream &operator<<(std::ostream &dest, __int128_t value) {
  std::ostream::sentry s(dest);
  if (s) {
    __uint128_t tmp = value < 0 ? -value : value;
    char buffer[128];
    char *d = std::end(buffer);
    do {
      --d;
      *d = "0123456789"[tmp % 10];
      tmp /= 10;
    } while (tmp != 0);
    if (value < 0) {
      --d;
      *d = '-';
    }
    int len = std::end(buffer) - d;
    if (dest.rdbuf()->sputn(d, len) != len) {
      dest.setstate(std::ios_base::badbit);
    }
  }
  return dest;
}
namespace pcf {
// initialize once by calling init()
#define MAXN 2000010       // initial sieve limit
#define MAX_PRIMES 2000010 // max size of the prime array for sieve
#define PHI_N 12500
#define PHI_M 166

int ACTUAL_MAX_PRIMES = 0; // total number of primes generated by sieve
int primes[MAX_PRIMES];
ll pref[MAXN];              // pref[i] --> number of primes <= i
static ll dp[PHI_N][PHI_M]; // precal of yo(n,k)
bitset<MAXN> f;

inline ll func(int p, int k) {
  if (k == 0)
    return 1;
  else if (k == 1)
    return p;
}

inline ll accfunc(ll n, int k) {
  if (k == 0)
    return n;
  else if (k == 1)
    return n * (n + 1) / 2;
}

void sieve(int n, int k) {
  f[1] = true;
  for (int i = 4; i <= n; i += 2)
    f[i] = true;
  for (int i = 3; i * i <= n; i += 2) {
    if (!f[i]) {
      for (int j = i * i; j <= n; j += i << 1)
        f[j] = 1;
    }
  }
  pref[0] = 0;
  for (int i = 1; i <= n; i++) {
    if (!f[i]) {
      primes[ACTUAL_MAX_PRIMES++] = i;
      pref[i] = pref[i - 1] + func(i, k); // ACTUAL_MAX_PRIMES;
    } else {
      pref[i] = pref[i - 1];
    }
  }
}

void init(int k) {
  sieve(MAXN - 1, k);
  // precalculation of phi upto size (PHI_N,PHI_M)
  for (int n = 0; n < PHI_N; n++)
    dp[n][0] = accfunc(n, k);
  for (int m = 1; m < PHI_M; m++) {
    for (int n = 0; n < PHI_N; n++) {
      dp[n][m] = dp[n][m - 1];
      if (n >= 2 * (ll)primes[m - 1] and n >= (ll)primes[m - 1] * primes[m - 1])
        dp[n][m] -= (ll)(dp[n / primes[m - 1]][m - 1]) * func(primes[m - 1], k);
      if (!(0 <= dp[n][m] and dp[n][m] <= (ll)n * (n + 1) / 2))
        cout << "n<<m=" << n << " " << m << endl;
    }
  }
}

// returns the number of integers less or equal n which are
// not divisible by any of the first k primes
// recurrence --> yo(n, k) = yo(n, k-1) - yo(n / p_k , k-1)
// for sum of primes yo(n, k) = yo(n, k-1) - p_k * yo(n / p_k , k-1)
ll Lehmer(ll n, int k);

ll yo(ll n, int m, int k) {
  if (n < PHI_N && m < PHI_M) {
    return dp[n][m];
  }
  if (m == 0) {
    ll v = accfunc(n, k);
    return v;
  }
  if (primes[m - 1] >= n) {
    ll v = 1 + Lehmer(n, k);
    return v;
  }
  ll v = yo(n, m - 1, k); // this can be max of n(n+1)/2
  ASSERT(0, v, (ll)n * (n + 1) / 2);
  ll takeaway =
      (n >= 2 * primes[m - 1] and n >= primes[m - 1] * primes[m - 1])
          ? (ll)yo(n / primes[m - 1], m - 1, k) * func(primes[m - 1], k)
          : 0;
  v -= takeaway;
  ASSERT(0, v, (ll)n * (n + 1) / 2);
  return v;
}

template <class T> void debug(std::initializer_list<T> list) {
  // #ifndef ONLINE_JUDGE
  for (auto elem : list)
    cout << elem << " ";
  cout << endl;
  // #endif
}

ll P2(ll n, int a, int b, int c, int k) {
  ll p2 = 0;
  for (int i = a; i < b; i++) {
    ll w = n / primes[i];
    ll t = (ll)(Lehmer(w, k) - Lehmer(primes[i - 1], k)) * func(primes[i], k);
    if (!(0 <= t and t <= (ll)n * (n + 1) / 2)) {
      debug({string("A:n,a,c,b,t="), to_string((long long)n), to_string(a),
             to_string(c), to_string(b), to_string(t),
             string("A:n,w,primes[i]Lw,Lp="), to_string((long long)n),
             to_string(w), to_string(primes[i]), to_string(Lehmer(w, k)),
             to_string(Lehmer(primes[i - 1], k))});
    }
    // ASSERT(0, t, (ll)n * (n + 1) / 2);
    p2 += t;
    // ASSERT(0, p2, (ll)n * (n + 1) / 2);
  }
  return p2;
}

ll P3(ll n, int a, int b, int c, int k) {
  ll p3 = 0;
  for (int i = a; i < b; i++) {
    ll w = (ll)n / primes[i];
    int lim =
        upper_bound(primes, primes + ACTUAL_MAX_PRIMES, sqrtl((double)w)) -
        primes;
    if (i <= c) {
      for (int j = i; j < lim; j++) {
        ll t = (ll)(Lehmer(w / primes[j], k) - (ll)Lehmer(primes[j - 1], k)) *
               (ll)func(primes[i], k) * func(primes[j], k);
        ASSERT(0, t, (ll)n * (n + 1) / 2);
        p3 += t;
        ASSERT(0, p3, (ll)n * (n + 1) / 2);
      }
    }
  }
  return p3;
}

ll Lehmer(ll n, int k) {
  if (n < 16)
    return pref[n];
  ll res = 0;
  int t = sqrtl(n);
  int a = upper_bound(primes, primes + ACTUAL_MAX_PRIMES, (ll)sqrt(t)) - primes;
  int c = upper_bound(primes, primes + ACTUAL_MAX_PRIMES, cbrt(n)) - primes;
  int b = upper_bound(primes, primes + ACTUAL_MAX_PRIMES, t) - primes;
  ll phi = yo(n, a, k);
  ll p2 = P2(n, a, b, c, k);
  ll p3 = P3(n, a, b, c, k);
  res = phi - 1 + Lehmer(primes[a - 1], k) - p2 - p3;
  ASSERT(0, res, (ll)n * (n + 1) / 2);
  return res;
}
} // namespace pcf

int32_t main() {
  const int k = 1;
  pcf::init(k);
  for (ll n = 1; n <= 10000000000000; n++) {
    auto start_time = clock();
    ll res = pcf::Lehmer(n, k);
    cout << "n = " << (double)n << " : " << res
         << "(time: " << (double)(clock() - start_time) / CLOCKS_PER_SEC << "s)"
         << endl;
  }
  return 0;
}
