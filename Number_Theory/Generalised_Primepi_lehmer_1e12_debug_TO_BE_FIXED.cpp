#include <bits/stdc++.h>
using namespace std;
// count prime timings
// n = 1e+08 : 5761374(time: 0.000147s)
// n = 1e+09 : 50847513(time: 0.000625s)
// n = 1e+10 : 455055057(time: 0.005021s)
// n = 1e+11 : 4118094746(time: 0.069805s)
// n = 1e+12 : 37607404117(time: 0.666591s)
// n = 1e+13 : 346029867905(time: 7.42527s)

// Sum prime timings
// n = 1e+09 : -5507193164078852(time: 0.001258s)
// n = 1e+10 : 4346955191190699564(time: 0.00956s)
// n = 1e+11 : -2366641945361200515(time: 0.098383s)
// n = 1e+12 : 9085273575588645537(time: 1.00599s)
// n = 1e+13 : -2701895728919619381(time: 8.78676s)

using ll = long long;
// using ll = __int128;

void ASSERT(ll minval, ll variable, ll maxval) {
  if (!(minval <= variable && variable <= maxval)) {
    cout << "ASSERT FAILED: " << minval << " " << variable << " " << maxval
         << " @ " << __FILE__ << " (" << __LINE__ << ")" << std::endl;
    exit(0);
  }
}

void ASSERT(bool condition) {
  if (!(condition)) {
    cout << "ASSERT FAILED: "
         << " @ " << __FILE__ << " (" << __LINE__ << ")" << std::endl;
    exit(0);
  }
}

// void ASSERT(bool condition){return ;}

std::ostream &operator<<(std::ostream &dest, __int128_t value) {
  std::ostream::sentry s(dest);
  if (s) {
    __uint128_t tmp = value < 0 ? -value : value;
    char buffer[128];
    char *d = std::end(buffer);
    do {
      --d;
      *d = "0123456789"[tmp % 10];
      tmp /= 10;
    } while (tmp != 0);
    if (value < 0) {
      --d;
      *d = '-';
    }
    int len = std::end(buffer) - d;
    if (dest.rdbuf()->sputn(d, len) != len) {
      dest.setstate(std::ios_base::badbit);
    }
  }
  return dest;
}
namespace pcf {
// initialize once by calling init()
#define MAXN 2000010       // initial sieve limit
#define MAX_PRIMES 2000010 // max size of the prime array for sieve
#define PHI_N 12500
#define PHI_M 166

int ACTUAL_MAX_PRIMES = 0; // total number of primes generated by sieve
int primes[MAX_PRIMES];
// int sumprimes[MAX_PRIMES];
ll pref0[MAXN];             // pref[i] --> number of primes <= i
ll pref[MAXN];              // pref[i] --> number of primes <= i
static ll dp[PHI_N][PHI_M]; // precal of yo(n,k)
bitset<MAXN> f;

inline ll func(int p, int k) {
  if (k == 0)
    return 1;
  else if (k == 1)
    return p;
  else
    cout << "WTF";
}

inline ll accfunc(ll n, int k) {
  if (k == 0)
    return n;
  else if (k == 1)
    return n * (n + 1) / 2;
  else
    cout << "WTF";
}

void sieve(int n, int k) {
  f[1] = true;
  for (int i = 4; i <= n; i += 2)
    f[i] = true;
  for (int i = 3; i * i <= n; i += 2) {
    if (!f[i]) {
      for (int j = i * i; j <= n; j += i << 1)
        f[j] = 1;
    }
  }
  pref0[0] = 0;
  pref[0] = 0;
  // sumprimes[0] = 2;
  for (int i = 1; i <= n; i++) {
    if (!f[i]) {
      primes[ACTUAL_MAX_PRIMES++] = i;
      // sumprimes[ACTUAL_MAX_PRIMES - 1] = ACTUAL_MAX_PRIMES > 1 ?
      // sumprimes[ACTUAL_MAX_PRIMES - 2] + i : i;
      pref0[i] = pref0[i - 1] + 1;
      pref[i] = pref[i - 1] + func(i, k); // ACTUAL_MAX_PRIMES;
    } else {
      pref0[i] = pref0[i - 1];
      pref[i] = pref[i - 1];
    }
  }
}

void init(int k) {
  sieve(MAXN - 1, k);
  // precalculation of phi upto size (PHI_N,PHI_M)
  for (int n = 0; n < PHI_N; n++)
    dp[n][0] = accfunc(n, k);
  for (int m = 1; m < PHI_M; m++) {
    for (int n = 0; n < PHI_N; n++) {
      dp[n][m] = dp[n][m - 1];
      if (n >= 2 * (ll)primes[m - 1] and n >= (ll)primes[m - 1] * primes[m - 1])
        dp[n][m] -= (ll)(dp[n / primes[m - 1]][m - 1]) * func(primes[m - 1], k);
      if (!(0 <= dp[n][m] and dp[n][m] <= (ll)n * (n + 1) / 2))
        cout << "n<<m=" << n << " " << m << endl;
    }
  }
  // for (int i = 74; i < 85 + 5; i++) {
  //   if (i < PHI_N)
  //     cout << endl << i << "=>";
  //   for (int j = 0; j < 13; j++) {
  //     if (i < PHI_N and j < PHI_N)
  //       cout << dp[i][j] << " ";
  //   }
  // }
  cout << endl;
}

// returns the number of integers less or equal n which are
// not divisible by any of the first k primes
// recurrence --> yo(n, k) = yo(n, k-1) - yo(n / p_k , k-1)
// for sum of primes yo(n, k) = yo(n, k-1) - p_k * yo(n / p_k , k-1)
ll Lehmer(ll n, int k);
// ll Lehmer0(ll n) {
//   if (n < 16)
//     return pref0[n];
//   return Lehmer(n, 0);
// }

ll yo_brute(ll n, int m, int k) {
  // cout << "starting yo_brute" << n << " " << m << endl;
  ll s = 1;
  for (int i = primes[m - 1] + 1; i <= n; i++) {
    bool coprime = true;
    for (int j = 0; j < m; j++) {
      if (i % primes[j] == 0) {
        coprime = false;
        break;
      }
    }
    s += coprime * func(i, k);
  }
  // cout << "returning yo_brute" << n << " " << m << " = " << s << endl;

  return s;
}

ll yo(ll n, int m, int k) {
  // cout << "starting yo" << n << " " << m << " " << k << endl;
  // ll ybt = yo_brute(n, m, k);
  if (n < PHI_N && m < PHI_M) {
    // cout << "returning yo" << n << " " << m << " = " << dp[n][m] << endl;
    return dp[n][m];
  }
  if (m == 0) {
    // ++n;
    ll v = accfunc(n, k);
    // cout << "returning yo" << n << " " << m << " " << k << " = " << v <<
    // endl;
    return v;
  }
  if (primes[m - 1] >= n) {
    ll v = 1 + Lehmer(n, k);
    // cout << "returning yo" << n << " " << m << " " << k << " = " << v <<
    // endl;
    return v;
  }
  ll pcol = yo(n, m - 1, k); // this can be max of n(n+1)/2
  ll takeaway = 0;
  if (n >= 2 * primes[m - 1] and n >= primes[m - 1] * primes[m - 1]) {
    takeaway = (ll)yo(n / primes[m - 1], m - 1, k) * func(primes[m - 1], k);
  }
  ll v = pcol - takeaway;
  if (v < 0)
    cout << n << " " << m << " " << pcol << " " << takeaway << " "
         << n / primes[m - 1] << endl;
  ASSERT(0, pcol, (ll)n * (n + 1) / 2);
  ASSERT(0, v, (ll)n * (n + 1) / 2);
  // if (v != ybt)
  //   cout << " n" << n << " m" << m << " k" << k << " yo" << v << " yo_b" <<
  //   ybt
  //        << endl;
  // ASSERT(v == yo_brute(n, m, k));
  // cout << "returning yo" << n << " " << m << " " << k << " = " << v << endl;
  return v;
}

template <class T> void debug(std::initializer_list<T> list) {
  // #ifndef ONLINE_JUDGE
  for (auto elem : list)
    cout << elem << " ";
  cout << endl;
  // #endif
}

ll P2_brute(ll n, int a, int b, int c, int k) {
  // cout << "starting P2: " << n << " " << a << " " << b << " " << c << endl;
  ll s = 0;
  for (int x = 4; x <= n; x++) {
    bool is_2_prime_prod = false;
    for (int i = 0; i < ACTUAL_MAX_PRIMES; i++) {
      if (a >= 1 and primes[i] <= primes[a - 1])
        continue;
      for (int j = i; j < ACTUAL_MAX_PRIMES; j++) {
        if (x % primes[i] == 0 and x % primes[j] == 0 and
            x == primes[i] * primes[j]) {
          is_2_prime_prod = true;
          break;
        }
      }
      if (is_2_prime_prod == true)
        break;
    }
    s += is_2_prime_prod * func(x, k);
    // if (is_2_prime_prod)
    //   cout << "Till" << n << " p2 =" << x << endl;
  }
  // cout << "returning P2_brute:" << n << " " << a << " " << b << " " << c <<
  // " = " << s << endl;
  return s;
}

ll P2(ll n, int a, int b, int c, int k) {
  // cout << "starting P2:" << n << " " << a << " " << b << " " << c << " " << k
  //      << endl;
  ll p2 = 0;
  for (int i = a; i < b; i++) {
    try {
      ll w = n / primes[i];
      ll t = (ll)(Lehmer(w, k) - Lehmer(primes[i - 1], k)) * func(primes[i], k);
      if (!(0 <= t and t <= (ll)n * (n + 1) / 2)) {
        debug({string("A:n,a,c,b,t="), to_string((long long)n), to_string(a),
               to_string(c), to_string(b), to_string(t),
               string("A:n,w,primes[i]Lw,Lp="), to_string((long long)n),
               to_string(w), to_string(primes[i]), to_string(Lehmer(w, k)),
               to_string(Lehmer(primes[i - 1], k))});
      }
      // ASSERT(0, t, (ll)n * (n + 1) / 2);
      p2 += t;
      // ASSERT(0, p2, (ll)n * (n + 1) / 2);

    } catch (const exception &e) {
      cout << e.what(); // information from error printed
    }
  }
  // if (p2 != P2_brute(n, a, b, c, k))
  //   cout << " n=" << n << " k=" << k << " p2=" << p2
  //        << " P2_brute =" << P2_brute(n, a, b, c, k) << endl;
  // ASSERT(p2 == P2_brute(n, a, b, c, k));

  // cout << "returning P2:" << n << " " << a << " " << b << " " << c << " " <<
  // k
  //      << " = " << p2 << endl;
  return p2;
}

ll P3_brute(ll n, int a, int b, int c, int k) {
  // cout << "starting P3_brute" << n << endl;
  ll s = 0;
  for (int x = 4; x <= n; x++) {
    bool is_3_prime_prod = false;
    for (int i = 0; i < ACTUAL_MAX_PRIMES and primes[i] <= n; i++) {
      if (a >= 1 and primes[i] <= primes[a - 1])
        continue;
      for (int j = i; j < ACTUAL_MAX_PRIMES and primes[j] <= n; j++) {
        for (int k = j; k < ACTUAL_MAX_PRIMES and primes[k] <= n; k++) {
          if (x % primes[i] == 0 and x % primes[j] == 0 and
              x % primes[k] == 0 and x == primes[i] * primes[j] * primes[k]) {
            is_3_prime_prod = true;
            break;
          }
        }
        if (is_3_prime_prod == true)
          break;
      }
      if (is_3_prime_prod == true)
        break;
    }
    s += is_3_prime_prod * func(x, k);
  }
  // cout << "returning P3_brute" << n << " = " << s << endl;
  return s;
}

ll P3(ll n, int a, int b, int c, int k) {
  // cout << "starting P3" << n << endl;
  ll p3 = 0;
  for (int i = a; i < b; i++) {
    ll w = (ll)n / primes[i];
    // int lim = Lehmer0(sqrtl((double)w));
    int lim =
        upper_bound(primes, primes + ACTUAL_MAX_PRIMES, sqrtl((double)w)) -
        primes;
    if (i <= c) {
      for (int j = i; j < lim; j++) {
        ll t = (ll)(Lehmer(w / primes[j], k) - (ll)Lehmer(primes[j - 1], k)) *
               (ll)func(primes[i], k) * func(primes[j], k);
        ASSERT(0, t, (ll)n * (n + 1) / 2);
        p3 += t;
        ASSERT(0, p3, (ll)n * (n + 1) / 2);
      }
    }
  }
  // if (p3 != P3_brute(n, a, b, c, k))
  //   cout << " n=" << n << " k=" << k << " p3=" << p3
  //        << " P3_brute =" << P3_brute(n, a, b, c, k) << endl;
  // ASSERT(p3 == P3_brute(n, a, b, c, k));
  // cout << "returning P3" << n << " = " << p3 << endl;
  return p3;
}

ll Lehmer(ll n, int k) {
  if (n < 16)
    return pref[n];
  ll res = 0;
  int t = sqrtl(n);
  int a = upper_bound(primes, primes + ACTUAL_MAX_PRIMES, (ll)sqrt(t)) - primes;
  int c = upper_bound(primes, primes + ACTUAL_MAX_PRIMES, cbrt(n)) - primes;
  int b = upper_bound(primes, primes + ACTUAL_MAX_PRIMES, t) - primes;
  ll phi = yo(n, a, k);
  // cout << "n,phi=" << n << ", " << phi << endl;
  ll p2 = P2(n, a, b, c, k);
  // cout << "n,p2=" << n << ", " << p2 << endl;
  ll p3 = P3(n, a, b, c, k);
  // cout << "n,p3=" << n << ", " << p3 << endl;
  res = phi - 1 + Lehmer(primes[a - 1], k) - p2 - p3;
  ASSERT(0, res, (ll)n * (n + 1) / 2);
  // debug({string("A:n="), to_string((long long)n), to_string(a), to_string(c),
  //        to_string(b), string("B(phi,p2,p3)"), to_string(phi), to_string(p2),
  //        to_string(p3)});
  return res;
}
} // namespace pcf

int32_t main() {
  vector<ll> ns = {
      // (ll)1e4,
      (ll)1e5,
      // (ll)1e6,  (ll)1e7,
      // (ll)1e8,
      // (ll)1e9, (ll)1e10, (ll)1e11, (ll)1e12, (ll)1e13,
  };
  const int k = 1;
  pcf::init(k);
  for (ll n = 1; n <= 10000000000000; n *= 10) {
    // for (ll n : ns) {
    auto start_time = clock();
    ll res = pcf::Lehmer(n, k);
    cout << "n = " << (double)n << " : " << res
         << "(time: " << (double)(clock() - start_time) / CLOCKS_PER_SEC << "s)"
         << endl;
  }
  return 0;
}
