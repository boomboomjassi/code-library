#include <bits/stdc++.h>
using namespace std;
// count prime timings
// n = 1e+08 : 5761374(time: 0.000147s)
// n = 1e+09 : 50847513(time: 0.000625s)
// n = 1e+10 : 455055057(time: 0.005021s)
// n = 1e+11 : 4118094746(time: 0.069805s)
// n = 1e+12 : 37607404117(time: 0.666591s)
// n = 1e+13 : 346029867905(time: 7.42527s)

// Sum prime timings
// Init time: 0.594631s
// n = 1e+10 : 2220822432581729238(time: 0.02622s + 0.594631s)
// n = 1e+11 : 201467077743744681014(time: 0.235392s + 0.594631s)
// n = 1e+12 : 18435588552550705911377(time: 2.24556s + 0.594631s)

using ll = long long;
using i128 = __int128;

#define ASSERT(minval, variable, maxval)                                       \
  {                                                                            \
    if (!(minval <= variable && variable <= maxval)) {                         \
      cout << "ASSERT FAILED: " << minval << " " << variable << " " << maxval  \
           << " @ " << __FILE__ << " (" << __LINE__ << ")" << endl;            \
      exit(0);                                                                 \
    }                                                                          \
  }
#define ASSERT2(condition)                                                     \
  {                                                                            \
    if (!(condition)) {                                                        \
      std::cerr << "ASSERT FAILED: " << #condition << " @ " << __FILE__        \
                << " (" << __LINE__ << ")" << std::endl;                       \
    }                                                                          \
  }

std::ostream &operator<<(std::ostream &dest, __int128_t value) {
  std::ostream::sentry s(dest);
  if (s) {
    __uint128_t tmp = value < 0 ? -value : value;
    char buffer[128];
    char *d = std::end(buffer);
    do {
      --d;
      *d = "0123456789"[tmp % 10];
      tmp /= 10;
    } while (tmp != 0);
    if (value < 0) {
      --d;
      *d = '-';
    }
    int len = std::end(buffer) - d;
    if (dest.rdbuf()->sputn(d, len) != len) {
      dest.setstate(std::ios_base::badbit);
    }
  }
  return dest;
}
namespace pcf {
// initialize once by calling init()
#define MAXN 20000010       // initial sieve limit
#define MAX_PRIMES 20000010 // max size of the prime array for sieve
#define PHI_N 125000
#define PHI_M 166

int ACTUAL_MAX_PRIMES = 0; // total number of primes generated by sieve
int primes[MAX_PRIMES];
ll pref0[MAXN];             // pref0[i] --> number of primes <= i
ll pref[MAXN];              // pref[i] --> precomputed Lehmer(i)
static ll dp[PHI_N][PHI_M]; // precal of yo(n,k)
bitset<MAXN> f;

inline ll func(int p, int k) {
  if (k == 0)
    return 1;
  else if (k == 1)
    return p;
}

inline i128 accfunc(ll n, int k) {
  if (k == 0)
    return n;
  else if (k == 1)
    return (i128)n * (i128)(n + 1) / 2;
}

void sieve(int n, int k) {
  f[1] = true;
  for (int i = 4; i <= n; i += 2)
    f[i] = true;
  for (int i = 3; i * i <= n; i += 2) {
    if (!f[i]) {
      for (int j = i * i; j <= n; j += i << 1)
        f[j] = 1;
    }
  }
  pref0[0] = 0;
  pref[0] = 0;
  for (int i = 1; i <= n; i++) {
    if (!f[i]) {
      primes[ACTUAL_MAX_PRIMES++] = i;
      pref0[i] = pref0[i - 1] + 1; // Irrespective of k always stores count .
                                   // from k=0 pref0 and pref are same
      pref[i] = pref[i - 1] + func(i, k); // ACTUAL_MAX_PRIMES;
    } else {
      pref0[i] = pref0[i - 1];
      pref[i] = pref[i - 1];
    }
  }
}

void init_tinyphi(int PHI_N, int PHI_M) {
  // precalculation of phi upto size (PHI_N,PHI_M)
  for (int n = 0; n < PHI_N; n++)
    dp[n][0] = accfunc(n, k);
  for (int m = 1; m < PHI_M; m++) {
    for (int n = 0; n < PHI_N; n++) {
      dp[n][m] = dp[n][m - 1];
      if (n >= (ll)primes[m - 1])
        dp[n][m] -= (ll)(dp[n / primes[m - 1]][m - 1]) * func(primes[m - 1], k);
//       if (!(0 <= dp[n][m] and dp[n][m] <= (ll)n * (n + 1) / 2))
//         cout << "n<<m=" << n << " " << m << endl;
    }
  }
}
  
void init(int k) {
  sieve(MAXN - 1, k);
  init_tinyphi(PHI_N, PHI_M);
}

// returns the number of integers less or equal n which are
// not divisible by any of the first k primes
// recurrence --> yo(n, k) = yo(n, k-1) - yo(n / p_k , k-1)
// for sum of primes yo(n, k) = yo(n, k-1) - p_k * yo(n / p_k , k-1)
i128 Lehmer(ll n, int k);

// O(m)=>O(pi(n^(1/4)))
// For n=10^9 =>O(min(pi(177))=O(20)
i128 yo(ll n, int m, int k) {
  if (n < PHI_N && m < PHI_M) {
    return dp[n][m];
  }
  if (m == 0) {
    i128 v = accfunc(n, k);
    return v;
  }
  if (primes[m - 1] >= n) {
    return 1;
  }
  i128 v = yo(n, m - 1, k); // this can be max of n(n+1)/2
  i128 takeaway = (n >= primes[m - 1])
                      ? yo(n / primes[m - 1], m - 1, k) * func(primes[m - 1], k)
                      : 0;
  v -= takeaway;
  return v;
}

template <class T> void debug(std::initializer_list<T> list) {
  // #ifndef ONLINE_JUDGE
  for (auto elem : list)
    cout << elem << " ";
  cout << endl;
  // #endif
}

// Tb(n) = (b-a)*[T(n/a)-T(b)] * c
// Tb(n) = (n*(1/2)-n^(1/4)) * [T(n/n*(1/4))-T(n*(1/2))] * c
// Tb(n) = (n*(1/2)) * [T(n*(3/4))-T(n*(1/2))] * c
// Tb(n) = (n*(1/2)) * [T(n*(3/4))] * c

i128 P2(ll n, int a, int b, int c, int k) {
  i128 p2 = 0;
  for (int i = a; i < b; i++) {
    ll w = n / primes[i];
    i128 t =
        (i128)(Lehmer(w, k) - Lehmer(primes[i - 1], k)) * func(primes[i], k);
    p2 += t;
  }
  return p2;
}

// Tb(n)=(n^(1/3)-n^(1/4))*[(n/n^(1/4))**(1/2)-n*(1/3)]*[T(n/a)-T(b)] * c
// Tb(n)=(n^(1/3)*(n^(3/8)-n^(1/3))*[T(n/w)-T(w)] * c
// Tb(n)=n^(1/3)*n^(3/8)*[T(n/n^(3/4))-T(n^(3/4))] * c
// Tb(n)=n^(17/24)*[T(n^(1/4))-T(n^(3/4))] * c
// Tb(n)=n^(17/24)*T(n^(3/4)) * c
i128 P3(ll n, int a, int b, int c, int k) {
  i128 p3 = 0;
  for (int i = a; i <= c; i++) {
    ll w = (ll)n / primes[i];
    int lim = pref0[(int)sqrtl(w)];
    for (int j = i; j < lim; j++) {
      i128 lehd_diff = Lehmer(w / primes[j], k) - Lehmer(primes[j - 1], k);
      i128 t =
          lehd_diff * ((i128)func(primes[i], k) * (i128)func(primes[j], k));
      p3 += t;
    }
  }
  return p3;
}

// T(n)=T(20)+n*(1/2) * T(n^(3/4)) * c2 + n^(17/24)*T(n^(3/4)) * c3
// T(n)= c1 + n*(1/2) * T(n^(3/4) * c2 + n^(17/24)*T(n^(3/4)) * c3
// T(n)= c1 + T(n^(3/4))[n^(1/2) * c2 + n^(17/24) * c3]
// T(n)= T(n^(3/4))[n^(17/24) * c3] #TODO calculation mighe be wrong here

i128 Lehmer(ll n, int k) {
  if (n < ACTUAL_MAX_PRIMES)
    return (i128)pref[n];
  i128 res = 0;
  int t = sqrtl(n);
  int a = pref0[(int)sqrt(t)];
  int c = pref[(int)cbrt(n)];
  int b = pref[t];
  auto start_time = clock();
  i128 phi = yo(n, a, k);
  start_time = clock();
  i128 p2 = P2(n, a, b, c, k);
  start_time = clock();
  i128 p3 = P3(n, a, b, c, k);
  res = phi - 1 + Lehmer(primes[a - 1], k) - p2 - p3;
  return res;
}
} // namespace pcf

int32_t main() {
  const int k = 1;
  auto start_time = clock();
  pcf::init(k);
  cout << "Init time: " << (double)(clock() - start_time) / CLOCKS_PER_SEC
       << "s" << endl;
  for (ll n = 10000000000; n <= 1000000000000; n *= 10) {
    start_time = clock();
    i128 res = pcf::Lehmer(n, k);
    cout << "n = " << (double)n << " : " << res
         << "(time: " << (double)(clock() - start_time) / CLOCKS_PER_SEC << "s)"
         << endl;
  }
  return 0;
}
